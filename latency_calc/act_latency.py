#!/usr/bin/python

#------------------------------------------------
# act_latency.py
#
# Analyze a act output file.
# Typical usage:
#	$ ./act_latency.py -l actout.txt
# where actout.txt is output generated by act,
# and which uses defaults:
# -t 3600
# -n 3
# -e 3
# (-x - not set)
#------------------------------------------------


#===========================================================
# Imports
#

import getopt
import re
import sys
import types


#===========================================================
# Constants
#

BUCKET_LABELS = ("00", "01", "02", "03", "04", "05", "06", "07", "08", "09", \
	"10", "11", "12", "13", "14", "15", "16")
ALL_BUCKETS = len(BUCKET_LABELS)
GAP_PAD = "  "


#===========================================================
# Function Definitions
#

#------------------------------------------------
# Parse a histogram total from a act output line.
#
def read_total_ops(line, file_id):
	total = long(line[line.find("(") + 1: line.find(" total)")])
	line = file_id.readline()
	return total, line

#------------------------------------------------
# Get one set of bucket values.
#
def read_bucket_values(line, file_id):
	values = [0] * ALL_BUCKETS
	total, line = read_total_ops(line, file_id)
	b_min = 0
	while True:
		found = 0
		for b in range(b_min, ALL_BUCKETS):
			pattern = '.*?\(' + BUCKET_LABELS[b] + ': (.*?)\).*?'
			r = re.compile(pattern)
			if r.search(line):
				found = found + 1
				values[b] = long(r.search(line).group(1))
		if found == 0:
			break
		line = file_id.readline()
		b_min = b_min + found
	return total, values, line

#------------------------------------------------
# Subtract one set of bucket values from another.
#
def subtract_buckets(new_values, old_values):
	slice_values = {}
	for b in range(ALL_BUCKETS):
		slice_values[b] = new_values[b] - old_values[b]
	return slice_values

#------------------------------------------------
# Get the percentage of operations within every bucket.
#
def bucket_percentages(total, values):
	percentages = [0.0] * ALL_BUCKETS
	if total > 0:
		for b in range(ALL_BUCKETS):
			percentages[b] = (float(values[b]) / total) * 100
	return percentages

#------------------------------------------------
# Get the percentage of operations in all buckets > bucket.
#
def percentage_over(bucket, percentages):
	percentage = 0.0
	for b in range(ALL_BUCKETS):
		if b > bucket:
			percentage = percentage + percentages[b]
	return percentage

#------------------------------------------------
# Get the data chunk reported by act at the specified after_time.
#
def read_chunk(file_id, after_time):
	find_line = "After " + str(after_time) + " "
	while True:
		line = file_id.readline()
		if not line:
			return 0, 0, 0, 0, 0, 0, False
		if line.startswith(find_line):
			break
	line = file_id.readline()
	while line and line.strip():
		if line.startswith("RAW READS"):
			raw_total, raw_values, line = read_bucket_values(line, file_id)
		elif line.startswith("READS"):
			trans_total, trans_values, line = read_bucket_values(line, file_id)
		elif line.startswith("LARGE BLOCK READS"):
			lbread_total, line = read_total_ops(line, file_id)
		elif line.startswith("LARGE BLOCK WRITES"):
			lbwrite_total, line = read_total_ops(line, file_id)
		else: 
			line = file_id.readline()
	try:
		lbread_total, lbwrite_total, \
		raw_total, raw_values, trans_total, trans_values
	except NameError:
		return 0, 0, 0, 0, 0, 0, False
	else:	
		return lbread_total, lbwrite_total, \
			raw_total, raw_values, trans_total, trans_values, True

#------------------------------------------------
# Generate padding.
#
def repeat(what, n):
	pad = ""
	for i in range(n):
		pad = pad + what
	return pad

#------------------------------------------------
# Print a latency data output line.
#
def print_line(slice_tag, trans_overs, raw_overs, max_bucket, every_nth, \
		extra = False, trans_rate = 0, lbread_rate = 0, lbwrite_rate = 0):
	output = "%5s" % (slice_tag) + GAP_PAD
	for i in range(max_bucket):
		if i % every_nth == 0:
			output = output + "%7.2f" % (trans_overs[i])
	output = output + GAP_PAD
	for i in range(max_bucket):
		if i % every_nth == 0:
			output = output + "%7.2f" % (raw_overs[i])
	if extra:
		output = output + GAP_PAD + " [" + "%.1f" % (trans_rate)
		output = output + ", " + "%.1f" % (lbread_rate)
		output = output + ", " + "%.1f" % (lbwrite_rate) + "]"
	print output

#------------------------------------------------
# Print usage.
#
def usage():
	print "Usage:"
	print " -l act output file"
	print "    MANDATORY - NO DEFAULT"
	print "    e.g. actout.txt"
	print " -t analysis slice interval in seconds"
	print "    default: 3600"
	print " -n number of buckets to display"
	print "    default: 3"
	print " -e show 0-th then every n-th bucket"
	print "    default: 3"
	print " -x (show extra information for each slice)"
	print "    default: not set"

#------------------------------------------------
# Main function.
#
def main(arg_log, arg_slice, arg_num_buckets, arg_every_nth, arg_extra):
	# Sanity-check the arguments:
	if arg_log == None:
		usage()
		sys.exit(-1)
	if arg_slice < 1:
		print "slice must be more than 0"
		sys.exit(-1)
	if arg_num_buckets < 1:
		print "num_buckets must be more than 0"
		sys.exit(-1)
	if arg_every_nth < 1:
		print "every_nth must be more than 0"
		sys.exit(-1)

	# Find index + 1 of last bucket to display:
	for b in range(ALL_BUCKETS):
		if b % arg_every_nth == 0:
			max_bucket = b + 1
			if arg_num_buckets == 1:
				break
			else:
				arg_num_buckets = arg_num_buckets - 1

	# Open the log file:
	try:
		file_id = open(arg_log, "r")
	except:
		print "log file " + arg_log + " not found."
		sys.exit(-1)

	# Find and echo the act version:
	version = "1.0"
	line = file_id.readline()
	while line and not line.startswith("Aerospike act"):
		line = file_id.readline()
	if not line:
		print "can't find any output data"
		sys.exit(-1)
	if line.split(" ")[2] == "version":
		version = line.split(" ")[3]
	print "data is act version " + version

	# Find the act reporting interval:
	line = file_id.readline()
	while line and not line.startswith("report-interval-sec"):
		line = file_id.readline()
	if not line:
		print "can't find report interval"
		sys.exit(-1)
	interval = long(line.split(" ")[1])

	# Sanity-check the act reporting interval:
	try:
		interval
	except:
		print "can't determine reporting interval"
		sys.exit(-1)

	# Find the histograms' scale:
	scale_label = " %>(ms)"
	file_id.seek(0, 0)
	line = file_id.readline()
	while line and not line.startswith("microsecond-histograms"):
		line = file_id.readline()
	if not line:
		print "can't find histograms' scale, assuming milliseconds"
		file_id.seek(0, 0)
	elif line.split(" ")[1].startswith("y"):
		scale_label = " %>(us)"

	# Adjust the slice time if necessary:
	slice_time = ((arg_slice + interval - 1) / interval) * interval
	if slice_time != arg_slice:
		print "analyzing time slices of " + str(slice_time) + " seconds"

	# Print the output table header:
	labels_prefix = "slice"
	len_labels_prefix = len(labels_prefix)
	threshold_labels = ""
	threshold_underline = ""
	for i in range(max_bucket):
		if i % arg_every_nth == 0:
			threshold_labels = threshold_labels + "%7s" % (pow(2, i))
			threshold_underline = threshold_underline + " ------"
	len_justify = len(threshold_labels) - 7
	prefix_pad = repeat(" ", len_labels_prefix)
	justify_pad = repeat(" ", len_justify)
	print prefix_pad + GAP_PAD + " trans " + justify_pad + GAP_PAD + " device"
	print prefix_pad + GAP_PAD + scale_label + justify_pad + GAP_PAD + \
		scale_label
	print labels_prefix + GAP_PAD + threshold_labels + GAP_PAD + \
		threshold_labels
	underline = repeat("-", len_labels_prefix) + GAP_PAD + \
		threshold_underline + GAP_PAD + threshold_underline
	print underline

	# Initialization before processing time slices:
	which_slice = 0
	after_time = slice_time
	old_lbread_total = 0
	old_lbwrite_total = 0
	old_trans_total = 0
	old_raw_total = 0
	old_trans_values = [0] * ALL_BUCKETS
	old_raw_values = [0] * ALL_BUCKETS
	trans_overs = [0.0] * max_bucket
	raw_overs = [0.0] * max_bucket
	avg_trans_overs = [0.0] * max_bucket
	avg_raw_overs = [0.0] * max_bucket
	max_trans_overs = [0.0] * max_bucket
	max_raw_overs = [0.0] * max_bucket

	# Process all the time slices:
	while True:
		new_lbread_total, new_lbwrite_total, \
		new_raw_total, new_raw_values, new_trans_total, new_trans_values, \
		got_chunk = read_chunk(file_id, after_time)
		if not got_chunk:
			# Note - we ignore the (possible) incomplete slice at the end.
			break

		# Get the "deltas" for this slice:
		slice_lbread_total = new_lbread_total - old_lbread_total
		slice_lbwrite_total = new_lbwrite_total - old_lbwrite_total
		slice_trans_total = new_trans_total - old_trans_total
		slice_raw_total = new_raw_total - old_raw_total
		slice_trans_values = \
			subtract_buckets(new_trans_values, old_trans_values)
		slice_raw_values = subtract_buckets(new_raw_values, old_raw_values)

		# Get the rates for this slice:
		lbread_rate = round(float(slice_lbread_total) / slice_time, 1)
		lbwrite_rate = round(float(slice_lbwrite_total) / slice_time, 1)
		trans_rate = round(float(slice_trans_total) / slice_time, 1)

		# Convert bucket values for this slice to percentages:
		trans_percentages = \
			bucket_percentages(slice_trans_total, slice_trans_values)
		raw_percentages = bucket_percentages(slice_raw_total, slice_raw_values)

		# For each (displayed) theshold, accumulate percentages over threshold:
		for i in range(max_bucket):
			if i % arg_every_nth:
				continue
			trans_overs[i] = round(percentage_over(i, trans_percentages), 2)
			raw_overs[i] = round(percentage_over(i, raw_percentages), 2)
			avg_trans_overs[i] = avg_trans_overs[i] + trans_overs[i]
			avg_raw_overs[i] = avg_raw_overs[i] + raw_overs[i]
			if (trans_overs[i] > max_trans_overs[i]):
				max_trans_overs[i] = trans_overs[i]
			if (raw_overs[i] > max_raw_overs[i]):
				max_raw_overs[i] = raw_overs[i]

		# Print this slice's percentages over thresholds:
		which_slice = which_slice + 1
		print_line(which_slice, trans_overs, raw_overs, \
			max_bucket, arg_every_nth, \
			arg_extra, trans_rate, lbread_rate, lbwrite_rate)

		# Prepare for next slice:
		old_lbread_total, old_lbwrite_total, \
		old_trans_total, old_raw_total, old_trans_values, old_raw_values = \
		new_lbread_total, new_lbwrite_total, \
		new_trans_total, new_raw_total, new_trans_values, new_raw_values
		after_time = after_time + slice_time

	# Print averages and maximums:
	if which_slice:
		for i in range(max_bucket):
			if i % arg_every_nth == 0:
				avg_trans_overs[i] = avg_trans_overs[i] / which_slice
				avg_raw_overs[i] = avg_raw_overs[i] / which_slice
		print underline
		print_line("avg", avg_trans_overs, avg_raw_overs, \
			max_bucket, arg_every_nth)
		print_line("max", max_trans_overs, max_raw_overs, \
			max_bucket, arg_every_nth)
	else:
		print "could not find " + str(slice_time) + " seconds of data"


#===========================================================
# Execution
#

# Read the input arguments:
try:
	opts, args = getopt.getopt(sys.argv[1:], "l:t:n:e:x", \
		["log=", "slice=", "num_buckets=", "every_nth=", "extra"])
except getopt.GetoptError, err:
	print str(err)
	usage()
	sys.exit(-1)

# Default values for arguments:
arg_log = None
arg_slice = 3600
arg_num_buckets = 7
arg_every_nth = 1
arg_extra = False

# Set the arguments:
for o, a in opts:
	if o == "-l" or o == "--log":
		arg_log = a
	if o == "-t" or o == "--slice":
		arg_slice = long(a)
	if o == "-n" or o == "--num_buckets":
		arg_num_buckets = int(a)
	if o == "-e" or o == "--every_nth":
		arg_every_nth = int(a)
	if o == "-x" or o == "--extra":
		arg_extra = True

# Call main():
main(arg_log, arg_slice, arg_num_buckets, arg_every_nth, arg_extra)
